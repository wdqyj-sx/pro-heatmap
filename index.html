<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <script src="./public/Cesium/Cesium.js"></script>
    <script src="./k.js"></script>
    <script src="./node_modules/axios/dist/axios.js"></script>
    <link rel="stylesheet" href="./public/Cesium/Widgets/widgets.css">
    <title>Document</title>
</head>

<body>
    <div id="cesiumContainer"></div>
    <script>
        Cesium.Ion.defaultAccessToken =
            'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJqdGkiOiJkZjg5NmQzMi1lN2M3LTQxZTktOTAyYS01MDFkM2RjYTgyOGMiLCJpZCI6MzQ2NjgsImlhdCI6MTYwMDY4Mzg0OX0.vv0m2W-E8Vmi3VleFtwfTRBYdSoNdBCS-COnZVgN3Zc'
        viewer = new Cesium.Viewer('cesiumContainer');
        axios({
            method: 'GET',
            url: 'http://localhost:3000/icorr?time=0',

        }).then(res => {
            let data = JSON.parse(res.data.data)
            let header = data[0].header
            console.log(header)
            let { dx, dy, la1, la2, lo1, lo2, nx, ny } = data[0].header
            let lngs = [], lats = [], siteValue = data[0].data
            for (let la = la1; la > la2; la -= dy) {
               
                    lats.push(la)
                
            }
         
                for (let lo = lo1; lo < lo2; lo += dx) {
                    lngs.push(lo)
                
            }
            let colors = [
                { min: 0, max: 1, color: "#A9F08E" },
                { min: 1, max: 1.5, color: "#72D66B" },
                { min: 1.5, max: 2, color: "#3DB83D" },
                { min: 2, max: 2.5, color: "#61B7FC" },
                { min: 2.5, max: 3, color: "#0001FE" },
                { min: 3, max: 3.5, color: "#FD00FA" },
                { min: 3.5, max: 4, color: "#7F013E" },
            ]
            let coords = [lo1, la1, lo1, la2, lo2, la1, lo2, la2]
            if (siteValue.length > 3) {
                const polygon = new Cesium.PolygonGeometry({
                    polygonHierarchy: new Cesium.PolygonHierarchy(
                        Cesium.Cartesian3.fromDegreesArray(coords)
                    )

                })
             
                let extent = Cesium.PolygonGeometry.computeRectangle({
                    polygonHierarchy: new Cesium.PolygonHierarchy(
                      
                        Cesium.Cartesian3.fromDegreesArray(coords)
                    )
                });//范围（弧度）
                let minx = Cesium.Math.toDegrees(extent.west);//转换为经纬度
                let miny = Cesium.Math.toDegrees(extent.south);
                let maxx = Cesium.Math.toDegrees(extent.east);
                let maxy = Cesium.Math.toDegrees(extent.north);
                let canvas = null;//画布
                function getCanvas () {
                    //1.用克里金训练一个variogram对象
                    let variogram = kriging.train(siteValue, lngs, lats, 'exponential', 0, 100);
                    //2.使用刚才的variogram对象使polygons描述的地理位置内的格网元素具备不一样的预测值；
                    let grid = kriging.grid(ex, variogram, (maxy - miny) / 500);
                    canvas = document.createElement('canvas');
                    canvas.width = 1000;
                    canvas.height = 1000;
                    canvas.style.display = 'block';
                    canvas.getContext('2d').globalAlpha = 1;//设置透明度
                    //3.将得到的格网预测值渲染到canvas画布上
                    debugger
                    kriging.plot(canvas, grid, [minx, maxx], [miny, maxy], colors);
                }
                getCanvas();
                if (canvas != null) {
                    KrigingObj = viewer.entities.add({
                        id: "KrigingRain",
                        polygon: {
                            show: ShowName == "drawKriging" ? true : false,
                            clampToGround: true,
                            hierarchy: {
                                positions: Cesium.Cartesian3.fromDegreesArray(coords)
                            },
                            material: new Cesium.ImageMaterialProperty({
                                image: canvas//使用贴图的方式将结果贴到面上
                            })
                        }

                    })
                }
            }
        })
    </script>
</body>

</html>